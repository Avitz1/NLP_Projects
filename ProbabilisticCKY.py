import sys
from sys import argv
import math

# a function that gets a file name and returns a list of sentences
def get_sentences(file_name):
    sentences = []
    f = open(file_name, 'r')
    for line in f:
        sentences.append(line.split())
    return sentences

# a function that gets a list of rules that look like this "1.0 S -> NP VP" or "0.25 D -> a"
# and returns 2 lists of rules that look like this [1.0, 'S', 'NP', 'VP'] and [0.25, 'D', 'a']
def get_rules(grammar):
    terminals = []
    non_terminals = []
    for line in grammar:
        rule = line.split()
        if len(rule) == 5:
            non_terminals.append([float(rule[0]), rule[1], rule[3], rule[4]])
        else:
            terminals.append([float(rule[0]), rule[1], rule[3]])
    return terminals, non_terminals

# A function that gets the grammer and the sentences and returns the table produced by the probabilistic CKY algorithm
# A possible content in an entry is [[4.6305e-06, 'S', [0.021, 'NP', [0.3, 'D', 'this'], [0.1, 'N', 'flight']], [0.00022049, 'VP', [0.3, 'V', 'goes'], [0.0021, 'PP', [0.3, 'P', 'to'], [0.00699999, 'NP', [0.1, 'D', 'some'], [0.1, 'N', 'city']]]]]]
def CKY(sentence, terminals, non_terminals):
    n = len(sentence)
    table = [[[] for i in range(n)] for j in range(n)]
    # fill the diagonal of the table with the rules for the terminals
    for i in range(n):
        for rule in terminals:
            if rule[2] == sentence[i]:
                table[i][i].append([rule[0], rule[1], sentence[i]])
    # fill the rest of the table
    for i in range(1, n):
        for j in range(n - i):
            for k in range(j, j + i):
                for rule in non_terminals:
                    for left in table[j][k]:
                        for right in table[k + 1][j + i]:
                            if left[1] == rule[2] and right[1] == rule[3]:
                                table[j][j + i].append([rule[0] * left[0] * right[0], rule[1], left, right])
    return table
# A function that returns the most probable derivation of a sentence
def get_max_derivation(possible_derivations):
    max_prob = 0
    max_derivation = None
    for derivation in possible_derivations:
        if derivation[1] == 'S' and derivation[0] > max_prob:
            max_prob = derivation[0]
            max_derivation = derivation
    if max_prob == 0:
        return None, None
    else:
        return max_derivation, math.log(max_prob)

# Recursive function to print the tree in a nice way and in pre-order traversal
def print_parse_tree(parse_tree, depth=0):
    if len(parse_tree) == 3:
        print(" " * depth + parse_tree[1] + " > " + parse_tree[2])
    else:
        print(" " * depth + parse_tree[1])
        print_parse_tree(parse_tree[2], depth + 5)
        print_parse_tree(parse_tree[3], depth + 5)

# a function that gets a sentence and a grammar and prints the maximum probability parse tree for the sentence
# and the probability of the parse tree
def parse(sentence, terminals, non_terminals):
    table = CKY(sentence, terminals, non_terminals)
    max_s_derivation, max_prob = get_max_derivation(table[0][len(sentence) - 1])
    print("Sentence: " + " ".join(sentence))
    if max_s_derivation:
        # write the parse tree to the output file
        print("Parsing:")
        print_parse_tree(max_s_derivation, 0)
        print("Log Probability: " + str(max_prob) + "\n")
    else:
        print("*** This sentence is not a member of the language generated by the grammar ***\n")

if __name__ == '__main__':
    input_grammar = argv[1]         # The name of the file that contains the probabilistic grammar
    input_sentences = argv[2]       # The name of the file that contains the input sentences (tests)
    output_trees = argv[3]          # The name of the output file
    # input_grammar = "cfg.txt"
    # input_sentences = "testSentences.txt"
    # output_trees = "output_trees.txt"

    sentences = get_sentences(input_sentences)
    terminals, non_terminals = get_rules(open(input_grammar, 'r').readlines())

    original_stdout = sys.stdout  # Save a reference to the original standard output
    with open(output_trees, 'w') as f:
        sys.stdout = f
        for sentence in sentences:
            parse(sentence, terminals, non_terminals)
        sys.stdout = original_stdout
